# Transport-Layter Part1
* 어플리케이션과 네트워크 계층 사이에서 logical communication을 제공 (5계층으로 설명하면)
* 논리적인 연결: 직접적으로 두대의 컴퓨터가 연결된 것이 아닌 여러 라우터와 링크들을 거쳐서 연결되어 있는 것을 말함. 하지만 직접적으로 연결된 것처럼 보이게 하는 것
* 트랜스포트 프로토콜은 엔드 시스템에서 운영된다.
- 발신자 측: 어플리케이션 층에서 만든 메시지를 세그먼트로 감싸고 네트워크 층으로 보낸다.
- 수신자 측: 받으면 세그먼트를 메시지로 변환하고 어플리케이션으로 올림
* 주로 UDP와 TCP 프로토콜을 사용하는 층
### 네트워크와의 계층과의 차이
- 네트워크 층은 호스트와의 연결을 중심으로 생각, IP주소를 통해서 메시지를 옮김
<br> 메시지 전송이 가장 큰 목적
- 전송계층은 프로세스들간의 데이터 통신을 중점으로 생각한다.
- eg) a라는 호스트가 b라는 호스트에게 메시지를 보낼 때 b라는 목적지로 가져다 주는 것은 네트워크, 도착하고 어떤 프로세스에게 이 데이터를 줄지 생각하는 것은 트랜스 포트
### TCP/UDP
* TCP는 신뢰성 있고 순서가 있게 전송을 해준다.
1. Congestion Control: 네트워크가 혼잡한 상태라면 데이터 전송량을 조절하는 것
2. Flow Control: 수신 측의 데이터 환경을 고려하여 데이터 전송량을 조절하는 것
3. Connection setup: 수신 측이 데이터를 받을 환경이 되어있는지 확인 하는 것
* UDP 신뢰성이 없고 순서가 없이 전송한다.
1. 이렇게만 보면 별로 안좋아 보이겟지만, 동영상이나 스트리밍 재생에서는 이게 중요
- 별다른 연결 작업없어 바로 데이터를 계속 송출해줄수 있기 때문이다.
### Multi/Demultiplexing
* 여러 프로세스들이 보내는 데이터를 한 스트림에 묶는 것=Multi
* 한 스트림에 묶인 데이터를 풀어서 각각 프로세스들에게 나눠주는 것=Demulti
### Demultiplexing의 방법
* IP datagram에 소스 주소와 목적지 주소가 있듯이 각 세그먼트들도 소스 포트 넘버와 목적지 포트 넘버가 존재한다. 이 포트 넘버로 어떤 프로세스가 어떤 프로세스로 보내는 지 알수 있다.
* 네트워크는 호스트에게 가져다주고 트랜스포트는 호스트에 도착한 후 포트 넘버로 어떤 프로세스가 목적지인지 찾는 것이다. 이게 중요한 거 같다.
### UDP
* Connectionless: 수신자와 발신자간의 핸드 세이킹도 없고 발신자가 받든 못받든 내 알바 아니란 식으로 그냥 보내는거
* 그래도 에러는 조금 체크는 해줌(걍 에러가 있나 없나 정도)
* 멀티미디어 어플의 경우가 많이 씀. 이유는 영상보다가 안나오면 빡치니까
### UDP 쓰는 이유
* 일단 빠르다. 연결준비 같은 거 안해도 되고 걍 보내면 되니까
* 가볍고 간단하다. 서로의 상태를 확인 안해도 되고 헤더도 작다.
### DNS는 UDP
* DNS는 매우 자주 사용되는 서비스로 딜레이가 최소화 되어야 할 필요가 있다. 그러므로 TCP를 사용하면 계속 연결 준비해야되고 정신 없어짐
* 그리고 DNS 앱 자체가 신뢰성을 제공한다. 그 이유는 분산형으로 DNS가 동작하기 때문에 응답이 안와도 다른 DNS에서 응답을 받을 수 있기 때문이다.
* 또한 RIP 라우팅 업데이트도 UDP를 통해서 보내진다.
- 그 이유는 주기적으로 업데이트 내용이 보내어지므로 못받은 애들도 다음 전송 때 업데이트 내용을 받을 수 있기 때문이다.
