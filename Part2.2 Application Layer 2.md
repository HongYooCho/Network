# Part2.2 Application Layer
### SMTP
* 주로 클라이언트에서 서버로 email 메시지를 보낼 때 사용하는 TCP
* 서버에서 바로 받고 바로 준다.
* 3 Phase of transfer (Hand Shaking, Transfer of messages, closures)
* 시나리오
1. 앨리스는 밥의 메일 주소로 메시지를 보내기 위해 user agent를 사용한다.
2. UA는 메시지를 그녀의 메일 서버에 보낸다. 그러면 서버는 메시지 큐에 그녀의 메일을 저장한다.
3. 클라이언트 쪽 SMTP는 밥의 메일 서버에 연결을 시도한다.
4. SMTP 클라이언트는 TCP 연결을 통해 앨리스의 메시지를 보낸다.
5. 밥의 메일 서버는 앨리스의 메시지를 밥의 메일 박스에 둔다.
6. 밥은 그의 UA에서 메시지를 읽는다.
* HTTP와의 차이점
HTTP는 서버에 요청을 한 후, 서버에게서 데이터를 받는 (Pull) 반면 SMTP는 클라이언트가 서버에 데이터를 보내는 형식(Push)
* POP3
- 클라이언트가 메일을 서버에서 받으면 클라이언트 로컬에 메일을 저장시키고 서버에서는 그 메일을 지우는 방식
- 만약 회사에서 메일을 읽었으면 집에서는 메일을 볼 수가 없음
* IMAP
- 서버 자체에 폴더를 따로 만들어 메일들을 저장 시켜놓는 방법
* Web-base Email
- 유저와 서버 사이는 HTTP, 서버와 서버는 SMTP형식으로 보내는 방식
### DNS
* 우리가 웹 브라우저 주소창에 www.naver.com을(host name) 치면 자동적으로 해당 아이피주소를 할당해주는 시스템
* DNS는 계층적이고 분산적인 데이터 베이스이다.
* root server, TLD server(com, org, net 등), authoritative server, local DNS name server 등으로 구성되어 있다.
* local DNS server가 존재하는 이유: 이전에 찾았었던 아이피주소를 캐싱 개념으로 사용하여 빠르게 접근 가능할 수 있기 때문이다.
### DNS Iterative query
* 로컬 DNS 서버를 기준으로 계속적으로 리퀘스트와 리스폰스를 주고 받음
1) 호스트가 주소를 치고 local Dns server로 요청을 날림
2) 로컬은 루트에게 TLD의 아이피를 물어보고 응답을 받음
3) 루트에게서 얻은 아이피로 TLD에 접근 후 책임 서버의 아이피를 얻음
4) 책임 서버로 접근 후 해당하는 도메인 주소의 아이피 주소를 얻어옴
5) 얻어온 주소를 클라이언트에게 제공
- 이러한 구조는 로컬 서버에 많은 부하를 줄 수 있다.
### DNS Recursive query
* Iterative와는 달리 로컬에서 요청하고 받는 형식이 아닌 로컬에서 루트, 루트에서 TLD, TLD에서 책임서버로 접근 후 다시 백 트랙킹 하는 형식이다.
* 그러므로 로드 밸런싱이 되어 로컬 서버에만 부하가 몰빵 되지 않는다.
* 또한 지나가면서 각 파트의 서버들은 캐싱의 개념을 가지면서 굳이 책임 서버까지 안가도 중간에 IP주소를 얻을 수 있다.
* 모든 아이피 맵핑 정보를 알수 없으므로 캐싱할 때 TTL을 둠으로써 캐쉬가 자연스럽게 없어지게 한다.
- 문제: 웹 사이트가 업데이트가 되면 TTL이 만료되기 전까지는 업데이트가 되었는 지 아닌 지 알수 없다. 만약 TTL이 없다면 업데이트 된 사이트 정보를 알 수 가 없으므로 필요
### Why DNS distributed??
* 만약 중앙 서버로 하나의 DNS만 있다면 걔한테만 요청하면 얻을 수 있어서 엄청 간편하다.
* 대신 유지성도 낮고 부하가 심하며 서버가 고장나면 노답, 멀리 떨어져있는 경우 응답이 오랜 시간이 걸리게 되고 확장성도 낮다.
* 그러므로 분산형으로 설치하여 확장성을 높이고 유지성을 좋게 하자
### DNS Load Distribution
* 트래픽 분산을 위해서 커넥션 서버를 여러 개 두어 한 서버에만 접속하지 않고 여러서버에 접속 할 수 있도록 로드 밸런싱을 한다.
### P2P architecture
* 서버 클라이언트 구조가 아닌 피어들끼리 시간을 두고 반복하며 연결되고 IP주소가 바뀌는 것
* 임의의 피어들끼리 직접적으로 연결되어 파일을 주고 받을 수 있음
### 클라이언트 서버 구조 vs P2P
- us: 서버의 업로드 속도
- ui: 피어의 업로드 속도
- di: 피어의 다운로드 속도
* 클라이언트 서버 구조
- 클라이언트 서버 구조에서 N명의 클라이언트가 파일을 다운받는 속도
<br> Dc-s >= max{NF/Us, F/Dmin}
- NF/Us는 서버가 N개의 파일을 업로드하는데 걸리는 시간
- F/Dmin은 파일을 다운 받는 속도가 가장 느린 클라이언트의 속도
- 클라이언트 서버 구조에서는 N의 영향이 크므로 주로 NF/Us가 결정된다. 즉 사용자가 많아지면 많아질수록 속도가 계속해서 느려지는 문제가 발생하게 된다.
* P2P 구조
- 서버 클라이언트 구조와는 다르게 유저들도 업로드하는 능력이 있음
- P2P 구조에서 N명의 클라이언트가 다운을 받는 속도
<br>Max{F/Us, F/Dmin, NF/(Us+Ui의 합)}
-  클라이언트 서버구조와는 다르게 유저들도 업로드를 할 수 있으므로 아무리 n이 증가할 지라도 유저들의 업로드 수 또한 증가하여 리니어하게 속도가 올라가지 않는다. (로그 그래프처럼 올라가게 됨)
* 비트 토렌트 부분도 있지만 면접 문제에 잘 안나올거 같아서 스킵
