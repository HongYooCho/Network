# Application Layer Part 1
### Client-Server Architecture
* server: 항상 켜져있고 영구적 IP주소를 가진 존재, 유저의 리퀘스트에 대한 응답을 해주는 존재이다.
* Client: 서버에게 데이터를 요청하는 존재이고 네트워크 환경에 따라 아이피가 바뀐다.
### P2P Architecture
* 서버라는 존재없이 임의의 엔드 시스템끼리 직접 연결되어 통신 하는 것이다.
* 즉 유저가 요청도 하고 응답도 해주는 것.
* Self-scalability: 새로운 피어 들은 새로운 서비스 능력을 줄 수 있다. 또한 클라이언트 서버 구조와는 달리 사람이 많아지면 많아질 수록 속도도 빨라진다.
### Sockets
* 어플리케이션 층과 transport 층의 사이에 존재 하며 네트워크 프로그래밍에 있어서 필요한 존재이다.
* 이것을 이용해서 멀리 떨어져있는 어플리케이션의 프로세스끼리 통신 할 수 있다. 또한 어플리케이션이 네트워크를 이용하기 위한 하나의 통로이다.
### Addressing processes
* 각 호스트마다 아이피 주소를 가지고 있고 목적지 주소를 알아야만 서로 통신할 수 있다.
* 하나의 엔드 시스템에는 다양한 프로세스들이 존재한다(카톡, 전화, 인터넷등). 하나의 아이피를 가지고 있지만, 다른 포트번호들을 통해서 각 프로세스에 대한 일을 처리할 수 있다.
* 그러므로 identifier는 아이피 주소와 포트 넘버를 가지고 있다.
### Application-layer Protocols
* 어플리케이션 계층에서 사용되는 프로토콜의 이름: Message
* 메시지를 보낼 때 메시지를 어떤 방식으로 어떻게 보낼지 결정하는 Syntax와 보낸 데이터들의 semantics를 규정한다.
* 이렇게 어플리케이션끼리 통신을 할 때 위의 규칙들을 지켜가며 통신할 수 있도록 한다.
### Web and HTTP
* HTTP connection: HTTP의 경우 웹페이지를 확실하게 전송해야할 필요가 있으므로 TCP가 적합
* HTTP Connection의 단계
1) 클라이언트는 서버에게 TCP 연결 요청을 먼저 한다.
2) TCP 연결요청에 대해서 응답을 하고 연결을 받아 들인다.
3) HTTP 요청 메시지를 연결된 TCP 연결 소켓을 통해 전송한다.(여기에 유저가 원하는 오브젝트가 존재)
4) HTTP 서버는 요청 메시지를 받고 응답 메시지를 만들며(유저가 요청한 오브젝트를 싣고) 유저의 소켓쪽에 다시 보낸다.
5) 서버는 TCP연결을 끊는다.
6) 유저는 원하는 오브젝트를 얻게 된다.
### HTTP connection: response time
* RTT: 패킷이 클라이언트에서 서버로 보내지고 다시 돌아오는 시간
* HTTP response time
- TCP connection을 맺는데 1RTT가 소요된다.
- HTTP request와 HTTP response 시간으로 또 1RTT 추가
- 그리고 response때 파일을 보내는 시간을 포함해야함
즉 2RTT+파일 전송시간이 걸림
* non-persistent HTTP: TCP 연결 한번에 오브젝트 최대 하나 보낸다.
- 보낸 후에는 연결이 끊기고 2RTT가 걸린다.
- 여러 개의 파일을 다운받으려면 계속 열고 닫고 해야함 (비효율적임)
* persistent HTTP: 응답을 보낸 후에도 서버는 TCP연결을 열어 놓는 것
- 여러 개의 파일을 다운 받을 때 계속 TCP 연결을 갱신 할 필요 없다.
- 계속 TCP를 열어놓는 것이 아닌 특정 시간 후 동안에만 열어놓는다.
### Cookies
* HTTP는 파일을 전송하고 나서 끊기면 그에 대한 정보를 저장하지 않는다.
* 쿠키 파일은 유저의 호스트에서 저장이되고 실행된다. (이게 중요)’
- ex) a라는 클라이언트가 어떤 상품을 사기위해 아마존에 접속 하는 경우
1) a는 http request를 보내고 아마존 서버는 유저에게 아이디를 할당하고 자신의 백엔드 서버에 저장한다. (저장하는 정보가 워낙 작아 백엔드가 터질일은 없음)
2) 서버가 http request를 보낼 때, 클라이언트에게 아마존 서버가 만든 쿠키 아이디를 같이 실어 보내서 클라이언트가 아마존에 접근할 때 사용할 쿠키 번호를 저장하게 한다.
3) 다음에 유저가 요청을 보낼 때는 쿠키 정보도 같이 보내면서 서버가 쿠키를 받으면서 특별한 행동을 취할 수 있게 한다.
### Web caches (proxy server)
* client와 origin server 중간에 proxy server를 둠으로써 proxy server를 캐쉬처럼 사용할 수 있게 한다.
- 사용 예)
1. 클라이언트가 Origin Server에 요청을 보내고 응답을 받을 때 프록시 서버에서는 그 요청과 응답에 대한 정보를 저장한다.
2. 다른 클라이언트가 같은 origin server에 요청을 보낼 때 프록시 서버는 저장한 정보를 바로 클라이언트에게 보내줌으로써 멀리 떨어진 origin server까지 갈 필요없게끔 하여 시간을 절약할 수 있다.
* 웹 캐싱의 장점
1. 클라이언트의 요청에 따른 응답 시간을 줄여준다.
2. 프록시 서버내에서 처리할 수 있으므로 다른 링크들을 타지 않아도 되서 트래픽을 줄일 수 있다.
3. Origin Server의 성능이 좋지 않더라도 웹캐시에서 컨텐츠를 제공할 수 있는 장점이 있다.
### FTP(File Transfer Protocol)
* 파일을 멀리떨어진 호스트에게 전송할 때 사용하는 프로토콜
* HTTP 서버와는 별개의 서버로 FTP 서버가 존재
* FTP의 경우 HTTP와는 다르게 TCP를 두가지 방식으로 연결한다. (컨트롤, 데이터)
1. FTP 클라이언트는 TCP를 사용하여 FTP서버에 접속
2. 컨트롤 커넥션을 통해서 클라이언트는 권한을 받는다.
3. 클라이언트는 원격 디렉토리를 탐색하고 컨트롤 커넥션을 통해 명령을 전송
4. 서버가 파일 전송 명령을 받으면 서버는 클라이언트에 두번째 TCP 데이터 연결을 시도
5. 데이터 파일을 전송한 후, 서버는 데이터 연결을 닫는다.
6. 서버는 또다른 데이터 커넥션을 열고 다른 파일을 전송한다.
* 여기서 중요한점: TCP 컨트롤 연결 링크와 데이터 링크는 별개. 컨트롤은 클라이언트가 요청할 때 사용하는 것처럼 컨트롤용으로 사용하고 데이터 링크는 데이터 전송을 위한 링크
- 그러므로 데이터 링크로 데이터를 보낼 때 컨트롤 링크는 out of band
